NAME
    AnyEvent::PocketIO::Client - pocketio client

SYNOPSIS
        # This APIs will be changed.

        use AnyEvent;
        use AnyEvent::PocketIO::Client;
    
        my $client = AnyEvent::PocketIO::Client->new;    

        $client->on('message' => sub {
            print STDERR "get message : $_[1]\n";
        });

        # first handshake, then open.
    
        my $cv = AnyEvent->condvar;

        $client->handshake( $server, $port, sub {
            my ( $error, $self, $sesid, $hb_timeout, $con_timeout, $trans ) = @_;

            $client->open( 'websocket' => sub {

                $self->reg_event('foo' => sub {
                    # ...
                });

                $cv->send;
            } );

        } );
    
        $cv->wait;
    
        # ... loop, timer, etc.
    
        $client->disconnect;

DESCRIPTION
    Async client using AnyEvent.

    This is beta version!

    APIs will be changed.

    Currently acceptable transport id is websocket only.

METHODS
  new
        $client = AnyEvent::PocketIO::Client->new( %opts )

    "new" takes options

    handshake_timeout

  handshake
        $client->handshake( $host, $port, $cb );

    The handshake routine. it executes a call back $cb that takes error,
    client itself, session id, heartbeat timeout, connection timeout and
    list reference of transports.

        sub {
            my ( $error, $client, $sesid, $hb_timeout, $conn_timeout, $trans ) = @_;
            if ( $error ) {
                say "code:", $error->{ code };
                say "message:", $error->{ message };
            }
            # ...        
        }

  open
        $client->open( $transport_id, $cb );

    After "handshake" success, makes a connection to the server. Currently
    $transport_id (case-insensitive) is "websocket" only.

    When the connection is made, $cb is executed. $cb takes error object and
    client object.

        sub {
            my ( $error, $client ) = @_;

            if ( $error ) {
                say "code:", $error->{ code };
                say "message:", $error->{ message };
            }

            # ...        
        }

  is_opened
        $boolean = $client->is_opend

  connect
        $client->connect( $endpoint )

  disconnect
        $client->disconnect( $endpoint )

  reg_event
        $client->reg_event( 'name' => $subref )

    Register an event triggered by server's emit.

    You should call this method after "open"ed.

  emit
        $client->emit( 'event_name', @args )

  send
        $client->send( 'message' )

  conn
        $conn = $client->conn; # PocketIO::Connection

  on
        $client->on( 'messsage_type' => $cb );

    Acceptable types are 'connect', 'disconnect', 'heartbeat' and 'message'.

  tranport
        my $transport = $client->transport();

SEE ALSO
    AnyEvent, PocketIO

AUTHOR
    Makamaka Hannyaharamitu, <makamaka[at]cpan.org>

COPYRIGHT AND LICENSE
    Copyright 2012 by Makamaka Hannyaharamitu

    This library is free software; you can redistribute it and/or modify it
    under the same terms as Perl itself.

